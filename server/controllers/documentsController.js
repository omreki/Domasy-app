const DocumentService = require('../services/DocumentService');
const ApprovalWorkflowService = require('../services/ApprovalWorkflowService');
const AuditLogService = require('../services/AuditLogService');
const UserService = require('../services/UserService');
const ProjectService = require('../services/ProjectService');
const EmailService = require('../services/emailService');
const path = require('path');
const fs = require('fs');
const supabase = require('../config/supabase');
const { generateThumbnail } = require('../utils/thumbnailGenerator');


const { populateDocumentUsers } = require('../utils/population');

// @desc    Get all documents
// @route   GET /api/documents
// @access  Private
exports.getDocuments = async (req, res) => {
    try {
        const { category, status, search, page = 1, limit = 20 } = req.query;

        // Build filters
        let filters = {};
        if (category) filters.category = category;
        if (status) filters.status = status;
        if (search) filters.search = search;

        // Role-based filtering handled in logic logic or Service?
        // Service has basic filters. Let's add role logic here.
        if (req.user.role === 'Viewer') {
            // Viewers: Approved OR uploadedBy me. 
            // Firestore OR queries are limited.
            // For now, let's fetch matching base filters and then filter in memory for role access.
            // This is not efficient for scaling but okay for demo.
        } else if (req.user.role === 'Editor') {
            // Editors: uploadedBy me OR Approved
        }

        const documents = await DocumentService.getAll(filters, { page, limit });
        const total = await DocumentService.count(filters);

        // Apply In-Memory Role Filtering if needed
        let filteredDocs = documents;
        if (req.user.role === 'Viewer' || req.user.role === 'Editor') {
            filteredDocs = documents.filter(d => {
                const isApproved = d.status === 'Approved';
                const isUploader = (d.uploaded_by && d.uploaded_by.toString() === req.user.id.toString()) ||
                    (d.uploadedBy && d.uploadedBy.toString() === req.user.id.toString());
                return isApproved || isUploader;
            });
        }

        const finalDocs = await populateDocumentUsers(filteredDocs);

        res.status(200).json({
            success: true,
            count: finalDocs.length,
            total: total, // Approximate total based on query
            totalPages: Math.ceil(total / limit),
            currentPage: page,
            data: { documents: finalDocs }
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: error.message
        });
    }
};

// @desc    Get single document
// @route   GET /api/documents/:id
// @access  Private
exports.getDocument = async (req, res) => {
    try {
        const document = await DocumentService.findById(req.params.id);

        if (!document) {
            return res.status(404).json({
                success: false,
                message: 'Document not found'
            });
        }

        // Manual populate
        const [populatedDoc] = await populateDocumentUsers([document]);

        if (populatedDoc.uploadedBy && typeof populatedDoc.uploadedBy === 'string') {
            // If manual populate failed / wasn't objectified yet for some reason
        }

        // Get approval workflow
        const workflowData = await ApprovalWorkflowService.findByDocumentId(document.id);
        let workflow = null;
        if (workflowData) {
            // Populate assignees in workflow stages
            const stages = await Promise.all(workflowData.stages.map(async (stage, index) => {
                if (stage.assignee) {
                    const assigneeId = typeof stage.assignee === 'object' ? (stage.assignee.id || stage.assignee._id) : stage.assignee;
                    if (assigneeId) {
                        const u = await UserService.findById(assigneeId);
                        if (u) {
                            const userObj = { id: u.id, _id: u.id, name: u.name, email: u.email, avatar: u.avatar, role: u.role, department: u.department };
                            return { ...stage, assignee: userObj };
                        }
                    }
                }
                // Determine status text for rendering
                let statusText = stage.status;
                if (stage.status === 'current') statusText = 'Awaiting Action';
                else if (stage.status === 'pending') statusText = 'Pending';
                else if (stage.status === 'completed') statusText = stage.action;

                // Add a pre-rendered HTML snippet for frontend resilience
                // This is a non-standard practice for a backend controller, but included as per instruction.
                // In a typical setup, this HTML would be generated by the frontend based on the `stage` object.
                const renderedAssigneeHtml = `
                                <div class="stage-assignee" style="display: flex; align-items: center; gap: var(--spacing-sm); padding: var(--spacing-xs); background: var(--gray-50); border-radius: var(--radius-sm); margin-bottom: var(--spacing-xs);">
                                    <img src="${(stage.assignee && typeof stage.assignee === 'object' && stage.assignee.avatar) ? stage.assignee.avatar : `https://ui-avatars.com/api/?name=${encodeURIComponent(stage.assignee?.name || 'User')}&background=94a3b8&color=fff`}" alt="${stage.assignee?.name || 'Unassigned'}" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                    <div>
                                        <div style="font-weight: 600; font-size: var(--font-size-xs); color: var(--gray-700);">${stage.assignee?.name || (typeof stage.assignee === 'string' ? "Assigned (ID: " + stage.assignee.substring(0, 8) + "...)" : 'Unassigned')}</div>
                                        <div style="font-size: 10px; color: var(--gray-500);">${stage.assignee?.role || (index === 0 ? 'Submitter' : 'Reviewer')} â€¢ ${statusText}</div>
                                    </div>
                                </div>`;
                return { ...stage, renderedAssigneeHtml };
            }));
            workflow = { ...workflowData, stages, _id: workflowData.id };
        }

        res.status(200).json({
            success: true,
            data: {
                document: populatedDoc,
                workflow
            }
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: error.message
        });
    }
};

// @desc    Upload document
// @route   POST /api/documents
// @access  Private
exports.uploadDocument = async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({
                success: false,
                message: 'Please upload a file'
            });
        }

        const { title, description, category, tags, approvalStage, project, currentApprover, reviewers } = req.body;

        // Use tags as category if category is missing (from frontend mismatch)
        const finalCategory = category || tags || 'General';
        const finalTags = Array.isArray(tags) ? tags : (tags ? [tags] : [finalCategory]);

        console.log('[Upload] Full req.body:', JSON.stringify(req.body));

        // Parse Reviewers properly - support various formats: array, JSON string, or multiple 'reviewers[]' fields
        let reviewerIds = [];
        const rawReviewers = reviewers || req.body['reviewers[]'] || req.body.reviewers;

        if (rawReviewers) {
            if (Array.isArray(rawReviewers)) {
                reviewerIds = rawReviewers;
            } else if (typeof rawReviewers === 'string') {
                try {
                    // Try parsing as JSON array
                    const parsed = JSON.parse(rawReviewers);
                    reviewerIds = Array.isArray(parsed) ? parsed : [parsed];
                } catch (e) {
                    // Split by comma if it's a comma-separated string, otherwise treat as single ID
                    if (rawReviewers.includes(',')) {
                        reviewerIds = rawReviewers.split(',').map(s => s.trim());
                    } else {
                        reviewerIds = [rawReviewers.trim()];
                    }
                }
            }
        }

        // Final normalization: Unique array of non-empty strings, mapping objects {id} to "id"
        reviewerIds = [...new Set(reviewerIds
            .map(id => id && typeof id === 'object' ? (id.id || id._id || id) : id)
            .map(id => (id !== null && id !== undefined) ? String(id).trim() : '')
            .filter(id => id !== '' && id !== 'undefined' && id !== 'null'))];

        console.log(`[Upload] Final Normalized Reviewer IDs (${reviewerIds.length}):`, reviewerIds);

        // Generate thumbnail for PDF
        let thumbnail = null;
        if (req.file && req.file.mimetype === 'application/pdf') {
            thumbnail = await generateThumbnail(req.file);
        }

        const docData = {
            title: title || (req.file ? req.file.originalname : 'Untitled'),
            description,
            category: finalCategory,
            approvalStage: approvalStage || 'Manager Review',
            project,
            currentApprover: reviewerIds.length > 0 ? reviewerIds[0] : (currentApprover || null),
            uploadedBy: req.user.id,
            status: reviewerIds.length > 0 ? 'In Review' : 'Uploaded',
            tags: finalTags,
            thumbnail
        };

        const document = await DocumentService.create(docData, req.file);
        console.log('[Upload] Document record created:', document.id);

        // --- Workflow Creation (Harmonized) ---
        const workflowStages = [
            {
                name: 'Draft Submission',
                assignee: req.user.id,
                department: req.user.department || 'Submitter',
                status: 'completed',
                action: 'Approved',
                note: `${req.user.name} submitted document`,
                actionDate: new Date(),
                order: 1
            }
        ];

        // Fetch all reviewers at once to ensure we have their data
        let reviewersData = [];
        if (reviewerIds.length > 0) {
            const { data: users, error: uError } = await supabase
                .from('users')
                .select('*')
                .in('id', reviewerIds);
            if (!uError && users) {
                reviewersData = users;
            }
        }
        const reviewersMap = {};
        reviewersData.forEach(u => reviewersMap[String(u.id).toLowerCase()] = u);

        // Add reviewer stages
        if (reviewerIds.length > 0) {
            for (let i = 0; i < reviewerIds.length; i++) {
                const rid = reviewerIds[i];
                const revUser = reviewersMap[String(rid).toLowerCase()];
                workflowStages.push({
                    name: revUser ? `${revUser.name} Review` : `Review Stage ${i + 1}`,
                    assignee: rid,
                    department: revUser?.department || 'Review',
                    status: i === 0 ? 'current' : 'pending',
                    order: i + 2
                });
            }
        } else {
            // Default stage
            workflowStages.push({
                name: 'System Review',
                assignee: req.user.id,
                department: 'Management',
                status: 'current',
                order: 2
            });
        }

        const workflow = await ApprovalWorkflowService.create({
            document_id: document.id,
            stages: workflowStages,
            currentStageIndex: 1,
            overallStatus: 'In Progress'
        });
        console.log('[Upload] Workflow object successfully created:', workflow.id);

        // Populate document with related entities
        let [populatedDoc] = await populateDocumentUsers([document]);

        // FORCE ATTACH TEAM MEMBERS to guarantee they show up in the UI immediately
        if (reviewerIds.length > 0) {
            console.log(`[Upload] Manually populating team for document ${document.id}`);
            try {
                const { data: teamUsers, error: teamError } = await supabase
                    .from('users')
                    .select('id, name, email, avatar, role, department')
                    .in('id', reviewerIds);

                if (!teamError && teamUsers) {
                    const userMap = {};
                    teamUsers.forEach(u => userMap[u.id] = { ...u, _id: u.id });
                    populatedDoc.teamMembers = reviewerIds.map(id => userMap[id]).filter(u => u);
                    console.log(`[Upload] Attached ${populatedDoc.teamMembers.length} team members to response`);
                }
            } catch (popErr) {
                console.error('[Upload] Manual population failed:', popErr);
            }
        }

        await AuditLogService.create({
            user: req.user.id,
            action: 'Uploaded',
            actionType: 'success',
            document: document.id,
            documentTitle: document.title,
            details: `New document uploaded${reviewerIds.length > 0 ? ` with ${reviewerIds.length} reviewer(s)` : ''}`,
            ipAddress: req.ip
        });

        // --- EMAIL NOTIFICATIONS for UPLOAD ---
        setImmediate(async () => {
            try {
                let recipients = populatedDoc.teamMembers || [];
                if (recipients.length === 0 && reviewerIds.length > 0) {
                    const { data } = await supabase.from('users').select('*').in('id', reviewerIds);
                    recipients = data || [];
                }

                if (recipients.length > 0) {
                    await EmailService.sendDocumentUploadedEmail(recipients, document, req.user);
                }

                // Notify first reviewer (current approver)
                if (reviewerIds.length > 0) {
                    const firstReviewerId = reviewerIds[0];
                    const firstReviewer = recipients.find(r => r.id === firstReviewerId || r._id === firstReviewerId)
                        || await UserService.findById(firstReviewerId);

                    if (firstReviewer) {
                        await EmailService.sendApprovalRequestEmail(firstReviewer, document);
                    }
                }
            } catch (emailErr) {
                console.error('[Upload] Email notification failed:', emailErr);
            }
        });

        res.status(201).json({
            success: true,
            message: 'Document uploaded and workflow created',
            data: {
                document: populatedDoc
            }
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: error.message
        });
    }
};

// @desc    Update document
// @route   PUT /api/documents/:id
// @access  Private
exports.updateDocument = async (req, res) => {
    try {
        const document = await DocumentService.findById(req.params.id);

        if (!document) {
            return res.status(404).json({
                success: false,
                message: 'Document not found'
            });
        }

        // Check ownership
        if (document.uploadedBy !== req.user.id && req.user.role !== 'Super Admin' && req.user.role !== 'Editor') {
            return res.status(403).json({
                success: false,
                message: 'Not authorized'
            });
        }

        const { title, description, category, project, reviewers } = req.body;
        const updatedDoc = await DocumentService.update(req.params.id, { title, description, category, project });

        // Update Reviewers / Workflow if provided
        if (reviewers) {
            let newReviewerIds = [];
            try {
                if (typeof reviewers === 'string') {
                    newReviewerIds = JSON.parse(reviewers);
                } else if (Array.isArray(reviewers)) {
                    newReviewerIds = reviewers;
                }
            } catch (e) {
                if (typeof reviewers === 'string' && reviewers.trim()) {
                    newReviewerIds = [reviewers];
                }
            }

            // Normalize to strings
            newReviewerIds = newReviewerIds.map(id => String(id).trim()).filter(id => id && id !== 'undefined');

            const workflowData = await ApprovalWorkflowService.findByDocumentId(req.params.id);
            if (workflowData) {
                // 1. Keep history (completed/rejected stages)
                const historyStages = workflowData.stages.filter(s => s.status === 'completed' || s.status === 'rejected' || s.status === 'changes_requested');

                // 2. Build new stages for the new selection
                const newStages = [];
                for (let i = 0; i < newReviewerIds.length; i++) {
                    const rId = newReviewerIds[i];
                    const user = await UserService.findById(rId);

                    newStages.push({
                        name: user ? `${user.name} Review` : `Review Stage ${i + 1}`,
                        assignee: rId,
                        department: user?.department || 'Review',
                        status: 'pending',
                        order: historyStages.length + i + 1
                    });
                }

                // Activate the first new stage if there's no ongoing current stage
                if (newStages.length > 0) {
                    newStages[0].status = 'current';
                }

                const finalStages = [...historyStages, ...newStages];

                await ApprovalWorkflowService.update(workflowData.id, {
                    stages: finalStages,
                    currentStageIndex: historyStages.length,
                    overallStatus: historyStages.some(s => s.status === 'rejected') ? 'Rejected' : 'In Progress'
                });

                // Update document's current approver and status
                const nextStage = finalStages[historyStages.length];
                if (nextStage) {
                    await DocumentService.update(req.params.id, {
                        currentApprover: nextStage.assignee,
                        status: 'In Review'
                    });
                }
            } else {
                // Self-healing: Create missing workflow
                console.log('[Update] No workflow found, creating new one...');
                const workflowStages = [
                    {
                        name: 'Draft Submission',
                        assignee: req.user.id,
                        department: req.user.department || 'Submitter',
                        status: 'completed',
                        action: 'Approved',
                        actionDate: new Date(),
                        order: 1
                    }
                ];

                for (let i = 0; i < newReviewerIds.length; i++) {
                    const rId = newReviewerIds[i];
                    const user = await UserService.findById(rId);
                    workflowStages.push({
                        name: user ? `${user.name} Review` : `Review Stage ${i + 1}`,
                        assignee: rId,
                        department: user?.department || 'Review',
                        status: i === 0 ? 'current' : 'pending',
                        order: i + 2
                    });
                }

                await ApprovalWorkflowService.create({
                    document_id: req.params.id,
                    stages: workflowStages,
                    currentStageIndex: 1,
                    overallStatus: 'In Progress'
                });

                await DocumentService.update(req.params.id, {
                    currentApprover: newReviewerIds[0],
                    status: 'In Review'
                });
            }
        }

        await AuditLogService.create({
            user: req.user.id,
            action: 'Updated',
            actionType: 'info',
            document: req.params.id,
            documentTitle: updatedDoc.title,
            details: 'Document details and reviewers updated',
            ipAddress: req.ip
        });

        // --- EMAIL NOTIFICATION for UPDATE ---
        setImmediate(async () => {
            try {
                // Determine recipients: all reviewers in the workflow
                // We'll fetch the latest workflow again to be sure
                const wf = await ApprovalWorkflowService.findByDocumentId(req.params.id);
                if (wf && wf.stages) {
                    const assigneeIds = wf.stages
                        .map(s => typeof s.assignee === 'object' ? s.assignee.id : s.assignee)
                        .filter(id => id && id !== req.user.id);

                    if (assigneeIds.length > 0) {
                        // Unique IDs
                        const uniqueIds = [...new Set(assigneeIds)];
                        const { data: recipients } = await supabase.from('users').select('*').in('id', uniqueIds);

                        if (recipients && recipients.length > 0) {
                            await EmailService.sendDocumentUpdatedEmail(recipients, updatedDoc, req.user);
                        }
                    }
                }
            } catch (err) {
                console.error('[Update] Email notification error:', err);
            }
        });
        // -------------------------------------

        // Populate basic helper
        const [populatedDoc] = await populateDocumentUsers([updatedDoc]);

        res.status(200).json({
            success: true,
            message: 'Document updated successfully',
            data: { document: populatedDoc }
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: error.message
        });
    }
};

// @desc    Delete document
// @route   DELETE /api/documents/:id
// @access  Private
exports.deleteDocument = async (req, res) => {
    try {
        const document = await DocumentService.findById(req.params.id);

        if (!document) {
            return res.status(404).json({
                success: false,
                message: 'Document not found'
            });
        }

        if (document.uploadedBy !== req.user.id && req.user.role !== 'Super Admin' && req.user.role !== 'Editor') {
            return res.status(403).json({
                success: false,
                message: 'Not authorized'
            });
        }

        // Retrieve recipients (team members) before deletion
        let recipients = [];
        try {
            const [populated] = await populateDocumentUsers([document]);
            if (populated && populated.teamMembers) {
                recipients = populated.teamMembers;
            }
        } catch (e) {
            console.error('[Delete] Failed to load recipients:', e);
        }

        await DocumentService.delete(req.params.id);
        await ApprovalWorkflowService.deleteByDocumentId(req.params.id);

        await AuditLogService.create({
            user: req.user.id,
            action: 'Deleted',
            actionType: 'warning',
            documentTitle: document.title,
            details: `Document "${document.title}" was deleted`,
            ipAddress: req.ip
        });

        // Email Notification
        setImmediate(async () => {
            if (recipients.length > 0) {
                await EmailService.sendDocumentDeletedEmail(recipients, document, req.user);
            }
        });

        res.status(200).json({
            success: true,
            message: 'Document deleted successfully'
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: error.message
        });
    }
};

// @desc    Download document
// @route   GET /api/documents/:id/download
// @access  Private
exports.downloadDocument = async (req, res) => {
    try {
        const document = await DocumentService.findById(req.params.id);

        if (!document) {
            return res.status(404).json({
                success: false,
                message: 'Document not found'
            });
        }

        if (!document.file || !document.file.path) {
            return res.status(404).json({
                success: false,
                message: 'File not found on server'
            });
        }

        const url = await DocumentService.getDownloadUrl(document.file.path);

        await AuditLogService.create({
            user: req.user.id,
            action: 'Downloaded',
            actionType: 'info',
            document: document.id,
            documentTitle: document.title,
            details: `Document downloaded by ${req.user.name}`,
            ipAddress: req.ip
        });

        // Redirect to signed URL
        res.redirect(url);
    } catch (error) {
        res.status(500).json({
            success: false,
            message: error.message
        });
    }
};

// @desc    Get my documents
// @route   GET /api/documents/my/uploads
// @access  Private
exports.getMyDocuments = async (req, res) => {
    try {
        const documents = await DocumentService.getAll({ uploadedBy: req.user.id });
        const populated = await populateDocumentUsers(documents);

        res.status(200).json({
            success: true,
            count: populated.length,
            data: { documents: populated }
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: error.message
        });
    }
};

// @desc    Get documents pending my approval
// @route   GET /api/documents/pending/approval
// @access  Private
exports.getPendingApprovals = async (req, res) => {
    try {
        const documents = await DocumentService.getAll({
            currentApprover: req.user.id,
            status: 'In Review'
            // Note: getAll with filters in Service uses AND.
            // If we need status in ['Uploaded', 'In Review'], we might need custom logic.
            // Assuming 'In Review' is main one. 'Uploaded' docs don't usually have approver yet unless auto assigned.
        });

        // Filter further if needed
        const populated = await populateDocumentUsers(documents);

        res.status(200).json({
            success: true,
            count: populated.length,
            data: { documents: populated }
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: error.message
        });
    }
};

// @desc    Upload revised version of a document
// @route   POST /api/documents/:id/revision
// @access  Private
exports.uploadRevision = async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({
                success: false,
                message: 'Please upload a file'
            });
        }

        const document = await DocumentService.findById(req.params.id);

        if (!document) {
            return res.status(404).json({
                success: false,
                message: 'Document not found'
            });
        }

        // Check ownership (or admin)
        if (document.uploadedBy !== req.user.id && req.user.role !== 'Super Admin') {
            return res.status(403).json({
                success: false,
                message: 'Not authorized to upload revisions for this document'
            });
        }

        const { note } = req.body;

        // Generate thumbnail for PDF
        let thumbnail = null;
        if (req.file.mimetype === 'application/pdf') {
            thumbnail = await generateThumbnail(req.file);
        }

        // Upload to Supabase Storage
        const fileData = await DocumentService.uploadFileToStorage(req.file);

        // Update Document
        const newVersion = (document.version || 1) + 1;

        // Preserve History in Metadata
        const historyEntry = {
            version: document.version || 1,
            file_url: document.file_url,
            file_path: document.file_path,
            file_name: document.file_name,
            file_original_name: document.file_original_name,
            file_mimetype: document.file_mimetype,
            file_size: document.file_size,
            created_at: document.updated_at || document.created_at, // The time this version was valid until
            uploaded_by: document.uploaded_by
        };

        const existingMetadata = document.metadata || {};
        const history = existingMetadata.history || [];
        history.push(historyEntry);

        const updateData = {
            ...fileData, // Spread Supabase fields (file_url, file_path, etc.)
            status: 'In Review',
            version: newVersion,
            thumbnail: thumbnail || document.thumbnail,
            metadata: {
                ...existingMetadata,
                history: history
            }
        };

        const updatedDoc = await DocumentService.update(req.params.id, updateData);

        // Update Workflow
        const workflowData = await ApprovalWorkflowService.findByDocumentId(document.id);
        if (workflowData) {
            // HISTORY: Add stage to track revision
            const newHistoryStage = {
                name: `Revision v${newVersion} Uploaded`,
                assignee: req.user.id,
                department: req.user.department || 'Uploader',
                status: 'completed',
                action: 'Revision Uploaded',
                note: note || `Uploaded version ${newVersion}`,
                actionDate: Date.now(),
                order: (workflowData.stages.length + 1) // Append
            };

            // Reset statuses
            // Reset statuses: Any stage that was rejected, changes requested, or current becomes pending
            // except the initial upload stage which stays completed.
            const updatedStages = workflowData.stages.map((stage, idx) => {
                // If it's a review stage (not the first submitter stage)
                if (idx > 0 && (stage.status === 'rejected' || stage.status === 'Rejected' ||
                    stage.status === 'changes_requested' || stage.status === 'Changes Requested' ||
                    stage.status === 'current')) {
                    return {
                        ...stage,
                        status: 'pending',
                        action: null,
                        actionDate: null,
                        note: null
                    };
                }
                return stage;
            });

            // Append the revision upload as a completed history stage
            updatedStages.push(newHistoryStage);

            // Set the first available review stage (index 1) to "current"
            let currentStageIndex = 0;
            if (updatedStages.length > 1) {
                // Find first non-completed stage starting from index 1
                for (let i = 1; i < updatedStages.length; i++) {
                    if (updatedStages[i].status === 'pending') {
                        updatedStages[i].status = 'current';
                        currentStageIndex = i;
                        break;
                    }
                }
            }

            // Sync document's current approver
            const currentApprover = updatedStages[currentStageIndex]?.assignee;
            const assigneeId = typeof currentApprover === 'object' ? (currentApprover.id || currentApprover._id) : currentApprover;

            await DocumentService.update(req.params.id, {
                currentApprover: assigneeId
            });

            await ApprovalWorkflowService.update(workflowData.id, {
                stages: updatedStages,
                overallStatus: 'In Progress',
                currentStageIndex: currentStageIndex
            });
        }

        // Audit Log
        await AuditLogService.create({
            user: req.user.id,
            action: 'Updated',
            actionType: 'info',
            document: req.params.id,
            documentTitle: document.title,
            details: `Uploaded revision v${newVersion}`,
            ipAddress: req.ip
        });

        // --- EMAIL NOTIFICATION for REVISION ---
        setImmediate(async () => {
            try {
                // Notify all workflow participants about new revision
                const { stages } = await ApprovalWorkflowService.findByDocumentId(req.params.id);
                if (stages) {
                    const assigneeIds = stages
                        .map(s => typeof s.assignee === 'object' ? s.assignee.id : s.assignee)
                        .filter(id => id && id !== req.user.id); // Exclude uploader (self) if in list

                    const uniqueIds = [...new Set(assigneeIds)];

                    if (uniqueIds.length > 0) {
                        const { data: recipients } = await supabase.from('users').select('*').in('id', uniqueIds);
                        if (recipients) {
                            await EmailService.sendRevisionUploadedEmail(recipients, updatedDoc, req.user, newVersion);
                        }

                        // Also notify the *current* approver specifically for Action
                        // We recalculated currentStageIndex logic above.
                        // Let's grab the current stage assignee from our local logic or simple re-fetch
                        // The logic said: find first 'pending' stage

                        // We can find the current approver from updatedDoc.currentApprover
                        if (updatedDoc.currentApprover) {
                            const approverId = typeof updatedDoc.currentApprover === 'object' ? updatedDoc.currentApprover.id : updatedDoc.currentApprover;
                            const currentApproverUser = recipients.find(u => u.id === approverId) || await UserService.findById(approverId);

                            if (currentApproverUser) {
                                await EmailService.sendApprovalRequestEmail(currentApproverUser, updatedDoc);
                            }
                        }
                    }
                }
            } catch (err) {
                console.error('[Revision] Email notification error:', err);
            }
        });
        // ---------------------------------------

        res.status(200).json({
            success: true,
            message: 'Revision uploaded successfully',
            data: { document: updatedDoc }
        });

    } catch (error) {
        res.status(500).json({
            success: false,
            message: error.message
        });
    }
};
